---
phase: 10-shadow-mode-measurement
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - src/shadow-mode/shadow-manager.ts
  - src/shadow-mode/metrics-collector.ts
  - src/orchestrator/test-orchestrator.ts
autonomous: true

must_haves:
  truths:
    - "Shadow manager evaluates all 6 categories against shadow thresholds"
    - "Shadow violations are logged without modifying decision.state"
    - "Shadow metrics are collected per-phase and persisted to JSON"
    - "All 63 existing phases still PASS after shadow mode integration"
    - "Shadow mode can be disabled via config without code changes"
  artifacts:
    - path: "src/shadow-mode/shadow-manager.ts"
      provides: "ShadowManager class that evaluates scores against shadow thresholds"
      exports: ["ShadowManager"]
      min_lines: 80
    - path: "src/shadow-mode/metrics-collector.ts"
      provides: "MetricsCollector class that persists shadow metrics to JSON"
      exports: ["MetricsCollector"]
      min_lines: 60
    - path: "src/orchestrator/test-orchestrator.ts"
      provides: "Updated orchestrator that calls shadow checks after existing enforcement"
      contains: "shadowManager"
  key_links:
    - from: "src/shadow-mode/shadow-manager.ts"
      to: "src/shadow-mode/threshold-config.ts"
      via: "Reads SHADOW_THRESHOLDS for comparison"
      pattern: "import.*SHADOW_THRESHOLDS"
    - from: "src/shadow-mode/shadow-manager.ts"
      to: "src/shadow-mode/shadow-types.ts"
      via: "Returns ShadowViolation arrays"
      pattern: "ShadowViolation"
    - from: "src/orchestrator/test-orchestrator.ts"
      to: "src/shadow-mode/shadow-manager.ts"
      via: "Calls shadowManager.evaluate() after threshold enforcement"
      pattern: "shadowManager.*evaluate"
    - from: "src/shadow-mode/metrics-collector.ts"
      to: "shadow-metrics directory"
      via: "Writes JSON files to metricsDir"
      pattern: "writeFileSync.*shadow-metrics"
---

<objective>
Implement the core shadow mode manager and integrate it into the test orchestrator.

Purpose: This is the central nervous system of shadow mode. The ShadowManager evaluates all 6 scoring categories against shadow thresholds and produces violations WITHOUT modifying decision.state. The MetricsCollector persists these metrics to JSON for later dashboard generation. The orchestrator calls shadow checks AFTER existing enforcement (line ~450 in executePhase, after all existing checks complete but before building PhaseResult).

Output: Working shadow mode that silently evaluates and persists metrics alongside every test run. Requirement SCORE-01 (shadow mode for new checks) is fulfilled.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-shadow-mode-measurement/10-RESEARCH.md
@.planning/phases/10-shadow-mode-measurement/10-01-SUMMARY.md

Key source files:
@dawati-tester/vertex-ai-testing/src/orchestrator/test-orchestrator.ts
@dawati-tester/vertex-ai-testing/src/shadow-mode/shadow-types.ts
@dawati-tester/vertex-ai-testing/src/shadow-mode/threshold-config.ts
@dawati-tester/vertex-ai-testing/src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ShadowManager and MetricsCollector</name>
  <files>
    dawati-tester/vertex-ai-testing/src/shadow-mode/shadow-manager.ts
    dawati-tester/vertex-ai-testing/src/shadow-mode/metrics-collector.ts
  </files>
  <action>
1. Create `src/shadow-mode/shadow-manager.ts`:

```typescript
import { ShadowModeConfig, ShadowViolation, ShadowMetrics, ShadowCategory } from './shadow-types';
import { SHADOW_THRESHOLDS, ENFORCED_THRESHOLDS } from './threshold-config';

export class ShadowManager {
  private config: ShadowModeConfig;

  constructor(config: ShadowModeConfig) {
    this.config = config;
  }

  /**
   * Evaluate all enabled categories against shadow thresholds.
   * Returns violations array WITHOUT modifying any decision state.
   *
   * CRITICAL: This method is READ-ONLY. It NEVER modifies decision.state.
   */
  evaluate(params: {
    phaseName: string;
    suiteName: string;
    rtlScore?: number;
    rtlChecks?: Array<{ checkName: string; score: number; issues: string[] }>;
    colorScore?: number;
    colorDetails?: Array<{ selector: string; property: string; actualColor: string }>;
    codeQualityScore?: number;
    codeQualityViolations?: Array<{ file: string; line: number; category: string; message: string }>;
    hardcodedStringsScore?: number;
    hardcodedStringsDetails?: Array<{ value: string; type: string; location: string }>;
    hardcodedColorsScore?: number;
    hardcodedColorsDetails?: Array<{ selector: string; property: string; actualColor: string }>;
    dynamicContentScore?: number;
    dynamicContentDetails?: Array<{ type: string; count: number }>;
  }): ShadowMetrics {
    const violations: ShadowViolation[] = [];
    const scores: ShadowMetrics['scores'] = {};

    // RTL shadow check
    if (this.config.categories.rtl && params.rtlScore !== undefined) {
      scores.rtl = params.rtlScore;
      const threshold = SHADOW_THRESHOLDS.rtl;
      if (params.rtlScore < threshold.shadow) {
        violations.push({
          category: 'rtl',
          phaseName: params.phaseName,
          suiteName: params.suiteName,
          currentScore: params.rtlScore,
          enforcedThreshold: threshold.enforced,
          shadowThreshold: threshold.shadow,
          wouldFail: true,
          currentlyFailing: params.rtlScore < threshold.enforced,
          details: (params.rtlChecks || [])
            .filter(c => c.score < 8)
            .slice(0, 5)
            .map(c => ({ name: c.checkName, score: c.score, issues: c.issues.slice(0, 3) })),
        });
      }
    }

    // Color shadow check
    if (this.config.categories.color && params.colorScore !== undefined) {
      scores.color = params.colorScore;
      const threshold = SHADOW_THRESHOLDS.color;
      if (params.colorScore < threshold.shadow) {
        violations.push({
          category: 'color',
          phaseName: params.phaseName,
          suiteName: params.suiteName,
          currentScore: params.colorScore,
          enforcedThreshold: threshold.enforced,
          shadowThreshold: threshold.shadow,
          wouldFail: true,
          currentlyFailing: params.colorScore < threshold.enforced,
          details: (params.colorDetails || [])
            .slice(0, 5)
            .map(d => ({ name: d.selector, score: 0, issues: [`${d.property}: ${d.actualColor}`] })),
        });
      }
    }

    // Code Quality shadow check
    if (this.config.categories.codeQuality && params.codeQualityScore !== undefined) {
      scores.codeQuality = params.codeQualityScore;
      const threshold = SHADOW_THRESHOLDS.codeQuality;
      if (params.codeQualityScore < threshold.shadow) {
        violations.push({
          category: 'codeQuality',
          phaseName: params.phaseName,
          suiteName: params.suiteName,
          currentScore: params.codeQualityScore,
          enforcedThreshold: threshold.enforced,
          shadowThreshold: threshold.shadow,
          wouldFail: true,
          currentlyFailing: params.codeQualityScore < threshold.enforced,
          details: (params.codeQualityViolations || [])
            .slice(0, 5)
            .map(v => ({ name: `${v.file}:${v.line}`, score: 0, issues: [`[${v.category}] ${v.message}`] })),
        });
      }
    }

    // Hardcoded Strings shadow check (DAT-01, DAT-02)
    if (this.config.categories.hardcodedStrings && params.hardcodedStringsScore !== undefined) {
      scores.hardcodedStrings = params.hardcodedStringsScore;
      const threshold = SHADOW_THRESHOLDS.hardcodedStrings;
      if (params.hardcodedStringsScore < threshold.shadow) {
        violations.push({
          category: 'hardcodedStrings',
          phaseName: params.phaseName,
          suiteName: params.suiteName,
          currentScore: params.hardcodedStringsScore,
          enforcedThreshold: threshold.enforced,
          shadowThreshold: threshold.shadow,
          wouldFail: true,
          currentlyFailing: params.hardcodedStringsScore < threshold.enforced,
          details: (params.hardcodedStringsDetails || [])
            .slice(0, 5)
            .map(d => ({ name: d.value, score: 0, issues: [`[${d.type}] at ${d.location}`] })),
        });
      }
    }

    // Hardcoded Colors shadow check (DAT-14)
    if (this.config.categories.hardcodedColors && params.hardcodedColorsScore !== undefined) {
      scores.hardcodedColors = params.hardcodedColorsScore;
      const threshold = SHADOW_THRESHOLDS.hardcodedColors;
      if (params.hardcodedColorsScore < threshold.shadow) {
        violations.push({
          category: 'hardcodedColors',
          phaseName: params.phaseName,
          suiteName: params.suiteName,
          currentScore: params.hardcodedColorsScore,
          enforcedThreshold: threshold.enforced,
          shadowThreshold: threshold.shadow,
          wouldFail: true,
          currentlyFailing: params.hardcodedColorsScore < threshold.enforced,
          details: (params.hardcodedColorsDetails || [])
            .slice(0, 5)
            .map(d => ({ name: d.selector, score: 0, issues: [`${d.property}: ${d.actualColor}`] })),
        });
      }
    }

    // Dynamic Content shadow check (DAT-15)
    if (this.config.categories.dynamicContent && params.dynamicContentScore !== undefined) {
      scores.dynamicContent = params.dynamicContentScore;
      const threshold = SHADOW_THRESHOLDS.dynamicContent;
      if (params.dynamicContentScore < threshold.shadow) {
        violations.push({
          category: 'dynamicContent',
          phaseName: params.phaseName,
          suiteName: params.suiteName,
          currentScore: params.dynamicContentScore,
          enforcedThreshold: threshold.enforced,
          shadowThreshold: threshold.shadow,
          wouldFail: true,
          currentlyFailing: params.dynamicContentScore < threshold.enforced,
          details: (params.dynamicContentDetails || [])
            .slice(0, 5)
            .map(d => ({ name: d.type, score: 0, issues: [`${d.count} issues`] })),
        });
      }
    }

    // Log to console if enabled (default: false)
    if (this.config.logToConsole && violations.length > 0) {
      console.log(`[Shadow Mode] ${params.phaseName}: ${violations.length} shadow violation(s)`);
      violations.forEach(v => {
        console.log(`  [Shadow] ${v.category}: ${v.currentScore.toFixed(1)}/${v.shadowThreshold} (would fail)`);
      });
    }

    return {
      phase: params.phaseName,
      suite: params.suiteName,
      timestamp: new Date().toISOString(),
      violations,
      scores,
    };
  }

  isEnabled(): boolean {
    return this.config.enabled;
  }
}
```

2. Create `src/shadow-mode/metrics-collector.ts`:

```typescript
import * as fs from 'fs';
import * as path from 'path';
import { ShadowMetrics, ShadowRunResult, ShadowCategory } from './shadow-types';

export class MetricsCollector {
  private metricsDir: string;
  private currentRunMetrics: ShadowMetrics[] = [];

  constructor(metricsDir: string) {
    this.metricsDir = metricsDir;
    fs.mkdirSync(metricsDir, { recursive: true });
  }

  /**
   * Record metrics for a single phase (in-memory)
   */
  recordPhase(metrics: ShadowMetrics): void {
    this.currentRunMetrics.push(metrics);
  }

  /**
   * Persist all collected metrics for the current run to JSON.
   * Appends to the existing metrics log file.
   */
  persistRun(suiteName: string): ShadowRunResult {
    const metricsFilePath = path.join(this.metricsDir, 'shadow-metrics.json');

    // Load existing metrics
    let allMetrics: ShadowMetrics[] = [];
    if (fs.existsSync(metricsFilePath)) {
      try {
        allMetrics = JSON.parse(fs.readFileSync(metricsFilePath, 'utf-8'));
      } catch {
        console.warn('[Shadow Metrics] Failed to parse existing metrics, starting fresh');
        allMetrics = [];
      }
    }

    // Append current run
    allMetrics.push(...this.currentRunMetrics);

    // Write back (limit to last 5000 entries to prevent unbounded growth)
    const toWrite = allMetrics.slice(-5000);
    fs.writeFileSync(metricsFilePath, JSON.stringify(toWrite, null, 2));

    // Compute run result
    const categories: ShadowCategory[] = ['rtl', 'color', 'codeQuality', 'hardcodedStrings', 'hardcodedColors', 'dynamicContent'];
    const violationsByCategory: Record<ShadowCategory, number> = {
      rtl: 0, color: 0, codeQuality: 0,
      hardcodedStrings: 0, hardcodedColors: 0, dynamicContent: 0,
    };

    let wouldFailCount = 0;
    const phasesWithViolations = new Set<string>();

    for (const m of this.currentRunMetrics) {
      if (m.violations.length > 0) {
        phasesWithViolations.add(m.phase);
      }
      for (const v of m.violations) {
        violationsByCategory[v.category]++;
        if (v.wouldFail) wouldFailCount++;
      }
    }

    const result: ShadowRunResult = {
      totalPhases: this.currentRunMetrics.length,
      phasesWithViolations: phasesWithViolations.size,
      violationsByCategory,
      wouldFailCount,
      metrics: this.currentRunMetrics,
    };

    // Also persist the run summary
    const summaryPath = path.join(this.metricsDir, `run-${Date.now()}.json`);
    fs.writeFileSync(summaryPath, JSON.stringify(result, null, 2));

    console.log(`[Shadow Metrics] Persisted ${this.currentRunMetrics.length} phase metrics`);
    console.log(`[Shadow Metrics] Phases with violations: ${phasesWithViolations.size}/${this.currentRunMetrics.length}`);
    console.log(`[Shadow Metrics] Would fail under shadow thresholds: ${wouldFailCount}`);

    // Reset for next run
    this.currentRunMetrics = [];

    return result;
  }

  /**
   * Get all historical metrics (for dashboard generation)
   */
  getAllMetrics(): ShadowMetrics[] {
    const metricsFilePath = path.join(this.metricsDir, 'shadow-metrics.json');
    if (!fs.existsSync(metricsFilePath)) return [];
    try {
      return JSON.parse(fs.readFileSync(metricsFilePath, 'utf-8'));
    } catch {
      return [];
    }
  }

  /**
   * Get metrics count (for checking baseline data sufficiency)
   */
  getMetricsCount(): number {
    return this.getAllMetrics().length;
  }
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` from `dawati-tester/vertex-ai-testing/`. Both new files should compile without errors.
  </verify>
  <done>
- ShadowManager.evaluate() returns ShadowMetrics without modifying any external state
- MetricsCollector.persistRun() writes to shadow-metrics.json and per-run summary
- Both files compile cleanly with `npx tsc --noEmit`
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate shadow mode into test-orchestrator.ts</name>
  <files>
    dawati-tester/vertex-ai-testing/src/orchestrator/test-orchestrator.ts
  </files>
  <action>
Modify `test-orchestrator.ts` to call shadow mode checks. The integration points are:

1. **Add imports** at the top of the file:
```typescript
import { ShadowManager } from '../shadow-mode/shadow-manager';
import { MetricsCollector } from '../shadow-mode/metrics-collector';
```

2. **Add class properties** in the TestOrchestrator class (after `parsedChecklistItems`):
```typescript
private shadowManager: ShadowManager | null = null;
private metricsCollector: MetricsCollector | null = null;
```

3. **Initialize in constructor** (after the autopilot block, around line 64):
```typescript
// Initialize shadow mode if enabled
if (config.shadowMode?.enabled) {
  this.shadowManager = new ShadowManager(config.shadowMode);
  this.metricsCollector = new MetricsCollector(config.shadowMode.metricsDir);
  console.log(`[Orchestrator] Shadow mode enabled (metrics dir: ${config.shadowMode.metricsDir})`);
}
```

4. **Add shadow evaluation in executePhase()** -- AFTER all existing checks complete (after the imageAssetResult block, around line 451, BEFORE the `const status =` line):

```typescript
// ─── SHADOW MODE: Evaluate against shadow thresholds (NEVER modifies decision.state) ───
let shadowResultForPhase: PhaseResult['shadowResult'] = undefined;
if (this.shadowManager && this.metricsCollector) {
  try {
    // Extract color score from RTL checks (check #11)
    const colorCheck = rtlResult?.checks?.find((c: any) => c.checkName === 'Design System Color Consistency');
    const colorScore = colorCheck?.score;
    const colorDetails = colorCheck ? [] : undefined; // Details handled by color checker

    // Extract dynamic content score from RTL checks (check #21)
    const dynamicCheck = rtlResult?.checks?.find((c: any) => c.checkName === 'Dynamic Content & Scripts');
    const dynamicScore = dynamicCheck?.score;

    const shadowMetrics = this.shadowManager.evaluate({
      phaseName: phase.name,
      suiteName: this.currentSuiteName,
      rtlScore: rtlResult?.overallScore,
      rtlChecks: rtlResult?.checks?.map((c: any) => ({ checkName: c.checkName, score: c.score, issues: c.issues || [] })),
      colorScore,
      colorDetails,
      codeQualityScore: codeQualityResult?.score,
      codeQualityViolations: codeQualityResult?.violations?.slice(0, 10).map((v: any) => ({
        file: v.file, line: v.line, category: v.category, message: v.message
      })),
      hardcodedStringsScore: hardcodedDetection?.score,
      hardcodedStringsDetails: [
        ...(hardcodedDetection?.hardcodedStrings || []).map(d => ({ value: d.value, type: d.type, location: d.location })),
        ...(hardcodedDetection?.mockData || []).map(d => ({ value: d.value, type: d.type, location: d.location })),
      ].slice(0, 10),
      hardcodedColorsScore: colorScore,  // Reuse color consistency score for hardcoded colors
      hardcodedColorsDetails: colorCheck ? [] : undefined,
      dynamicContentScore: dynamicScore,
      dynamicContentDetails: dynamicCheck ? [{ type: 'dynamic-content', count: dynamicCheck.issues?.length || 0 }] : undefined,
    });

    this.metricsCollector.recordPhase(shadowMetrics);

    // Populate shadowResult for PhaseResult (if there are violations)
    if (shadowMetrics.violations.length > 0) {
      shadowResultForPhase = {
        violations: shadowMetrics.violations.length,
        wouldFail: shadowMetrics.violations.some(v => v.wouldFail),
        details: shadowMetrics.violations.map(v => ({
          category: v.category,
          score: v.currentScore,
          shadowThreshold: v.shadowThreshold,
        })),
      };
      console.log(`[Shadow Mode] ${phase.name}: ${shadowMetrics.violations.length} shadow violation(s) recorded`);
    }
  } catch (shadowError: any) {
    console.warn(`[Shadow Mode] Shadow evaluation failed: ${shadowError.message}`);
  }
}
```

5. **Add shadowResult to PhaseResult** -- In the phaseResult object (around line 474), add after `imageAssetResult`:
```typescript
shadowResult: shadowResultForPhase,
```

6. **Persist shadow metrics at end of suite** -- In runTestSuite(), after the trend recording block (around line 200), before generating the report:
```typescript
// Persist shadow mode metrics for this run
if (this.metricsCollector) {
  try {
    const shadowRunResult = this.metricsCollector.persistRun(suiteName);
    console.log(`[Shadow Mode] Run complete: ${shadowRunResult.phasesWithViolations}/${shadowRunResult.totalPhases} phases have shadow violations`);
  } catch (shadowErr: any) {
    console.warn(`[Shadow Mode] Failed to persist shadow metrics: ${shadowErr.message}`);
  }
}
```

CRITICAL CONSTRAINTS:
- NEVER modify `decision.state` in shadow mode code
- All shadow code is wrapped in try/catch so failures don't break existing tests
- Shadow evaluation happens AFTER all existing threshold enforcement
- Shadow metrics persistence happens in runTestSuite() after all phases, not per-phase
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. Run one existing test suite to verify 63/63 PASS maintained:
   `npx ts-node tests/component-deep.test.ts` -- should still PASS all phases
3. Check that `shadow-metrics/` directory is created and contains JSON output
4. Verify no test failures caused by shadow mode integration
  </verify>
  <done>
- Shadow mode evaluates all 6 categories silently after existing checks
- Shadow violations logged to console only if `logToConsole: true`
- Metrics persisted to `shadow-metrics/shadow-metrics.json` after suite completion
- PhaseResult includes optional `shadowResult` with violation count
- All 63 existing phases maintain PASS status
- `npx tsc --noEmit` passes
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. Run any existing test suite -- all phases still PASS
3. `shadow-metrics/` directory created with `shadow-metrics.json`
4. Shadow violations logged in console during test run (showing what WOULD fail)
5. No modifications to `decision.state` anywhere in shadow code
6. Grep for `decision.state` in shadow-mode/ directory returns zero matches
</verification>

<success_criteria>
- SCORE-01 fulfilled: Shadow mode measures without failing
- Shadow Manager evaluates RTL, Color, CodeQuality, HardcodedStrings, HardcodedColors, DynamicContent
- Metrics persisted per-run with suite/phase/timestamp/violations
- Zero impact on 63/63 PASS rate
- Shadow mode can be disabled via SHADOW_MODE_ENABLED=false env var
</success_criteria>

<output>
After completion, create `.planning/phases/10-shadow-mode-measurement/10-02-SUMMARY.md`
</output>
